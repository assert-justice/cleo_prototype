// Generated automatically from json.wren. Do not edit.
static const char* json =
"\n"
"class Json {\n"
"\n"
"  //returns a Wren Map or List from a json string \n"
"  static parse(string) { parse("json", string) }\n"
"  static parse(source_id, source_string) {\n"
"    if(source_string == null) Fiber.abort("Expected string value for Json.parse")\n"
"    var parser = JsonParser.new(source_id, source_string)\n"
"    var root = parser.root\n"
"    parser = null\n"
"    return root\n"
"  }\n"
"\n"
"    //default is two spaces\n"
"  static stringify(value) { stringify(value, "  ") }\n"
"\n"
"    //with custom whitespace\n"
"  static stringify(value, whitespace) {\n"
"    var string = ""\n"
"    JsonStringify.stringify(value, whitespace) {|add|\n"
"      string = string + add\n"
"    }\n"
"    return string\n"
"  }\n"
"\n"
"    //with custom callback\n"
"  static stringify(value, whitespace, callback) {\n"
"    JsonStringify.stringify(value, whitespace, callback)\n"
"  }\n"
"\n"
"} //Json\n"
"\n"
"//Handles actual stringification,\n"
"//it calls out to the provided callback to handle "writing"\n"
"//which means you can e.g write to a file directly, or into a buffer, \n"
"//which is often significantly faster than concatenating strings\n"
"class JsonStringify {\n"
"\n"
"  static stringify(value, whitespace, out) {\n"
"\n"
"    if(!(value is Map || value is List)) {\n"
"      Fiber.abort("Json stringify requires a Map or a List as input")\n"
"    }\n"
"\n"
"    if(value is Map) {\n"
"      stringify_map(value, whitespace, 0, out)\n"
"    } else {\n"
"      stringify_value(value, whitespace, 0, out)\n"
"    }\n"
"\n"
"  } //stringify\n"
"\n"
"  static stringify_map(map, whitespace, depth, out) {\n"
"\n"
"    if(!(map is Map)) Fiber.abort("Expected a Map, received %(map.type) as %(map)")\n"
"    if(map.count == 0) return out.call("{}")\n"
"\n"
"    out.call("{\n")\n"
"\n"
"      var index = 0\n"
"      var count = map.count\n"
"      for(key in map.keys) {\n"
"\n"
"        out.call(whitespace * (depth + 1))\n"
"        out.call("\"%(key)\" : ")\n"
"\n"
"        var value = map[key]\n"
"        stringify_value(value, whitespace, depth + 1, out)\n"
"\n"
"        var last = index == count-1\n"
"        out.call(last ? "\n" : ",\n")\n"
"\n"
"        index = index + 1\n"
"\n"
"      } //each key\n"
"\n"
"    out.call(whitespace * depth)\n"
"    out.call("}")\n"
"\n"
"  } //stringify_map\n"
"\n"
"  static stringify_primitive(value, out) {\n"
"\n"
"    if(value is String) {\n"
"      var string = "%(value)"\n"
"        //basic json escaping. todo: this isn't extensive\n"
"        string = string.replace("\\", "\\\\") // double backslash must be first\n"
"        string = string.replace("\"", "\\\"") // then replace single \n"
"        string = string.replace("\n", "\\n")  \n"
"      out.call("\"%(string)\"")\n"
"    } else if(value is Num || value is Null || value is Bool) {\n"
"      out.call("%(value)")\n"
"    } else {\n"
"      Fiber.abort("Can't stringify type %(value.type)!")\n"
"    }\n"
"\n"
"  } //stringify_primitive\n"
"\n"
"  static stringify_list(list, whitespace, depth, out) {\n"
"\n"
"    if(!(list is List)) Fiber.abort("Expected a List, received %(list.type) as %(list)")\n"
"\n"
"      //clearer output if empty, simpler code\n"
"    if(list.count == 0) return out.call("[]")\n"
"\n"
"    out.call("[\n")\n"
"\n"
"      var index = 0\n"
"      var count = list.count\n"
"      for(item in list) {\n"
"        out.call(whitespace * (depth + 1))\n"
"        stringify_value(item, whitespace, depth + 1, out)\n"
"        var last = index == count - 1\n"
"        out.call(last ? "\n" : ",\n")\n"
"        index = index + 1\n"
"      } //each item\n"
"\n"
"    out.call(whitespace * depth)\n"
"    out.call("]")\n"
"\n"
"  } //stringify_list\n"
"\n"
"  static stringify_value(value, whitespace, depth, out) {\n"
"    if(value is Map) {\n"
"      stringify_map(value, whitespace, depth, out)\n"
"    } else if(value is List) {\n"
"      stringify_list(value, whitespace, depth, out)\n"
"    } else {\n"
"      stringify_primitive(value, out)\n"
"    }\n"
"  } //stringify_value\n"
"\n"
"} //JsonStringify\n"
"\n"
"\n"
"//There's some weird choices here from early on using wren but /shrug :)\n"
"class JsonParser {\n"
"\n"
"  root { _root }\n"
"\n"
"  construct new(source_id, source) {\n"
"\n"
"    _source_id = source_id\n"
"    _root = null\n"
"\n"
"    _EOF            = -1\n"
"    _ERR            = -2\n"
"    _NEW_LINE       = 10 //\n LF\n"
"    _OPEN_BRACE     = 123\n"
"    _CLOSE_BRACE    = 125\n"
"    _OPEN_BRACKET   = 91\n"
"    _CLOSE_BRACKET  = 93\n"
"    _OPEN_STRING    = 34\n"
"    _CLOSE_STRING   = 34\n"
"    _COLON          = 58\n"
"    _COMMA          = 44\n"
"    _EQUAL          = 61\n"
"    _TAB            = 9\n"
"    _SPACE          = 32\n"
"    _COMMENT        = 47\n"
"    _ESCAPED        = 92\n"
"\n"
"      //:todo: we could use a token and do it inline but for now\n"
"    source = source.replace("\r\n", "\n")\n"
"\n"
"    _cur = -1\n"
"    _line = 0\n"
"    _col = 0\n"
"    _end = source.count\n"
"    _points = source.codePoints\n"
"    _in_comment = 0\n"
"\n"
"    var pk = peek()\n"
"    if(pk == _OPEN_BRACKET) {\n"
"      _root = parse_list()\n"
"    } else if(pk == _OPEN_BRACE) {\n"
"      _root = parse_map()\n"
"    } else {\n"
"      Fiber.abort("expected a Map or List at the root")\n"
"    }\n"
"\n"
"  } //new\n"
"\n"
"  unexpected(point) {\n"
"    var err = "end of file"\n"
"    if(point != -1) err = String.fromCodePoint(point)\n"
"    Fiber.abort("unexpected `%(err)` at line %(_line):%(_col) (%(point)) in file `%(_source_id)`")\n"
"  } //unexpected\n"
"\n"
"  is_eof(point) { point == _EOF }\n"
"  is_whitespace(point) { point == _SPACE || point == _TAB  || point == _NEW_LINE }\n"
"  is_token(point) {\n"
"    return  point == _COMMA ||\n"
"            point == _COLON ||\n"
"            point == _CLOSE_BRACE ||\n"
"            point == _OPEN_BRACE ||\n"
"            point == _CLOSE_BRACKET ||\n"
"            point == _OPEN_BRACKET\n"
"  } //is_token\n"
"\n"
"  next() {\n"
"    _cur = skips(true) + 1\n"
"    if(_cur >= _end) return _EOF\n"
"    return _points[_cur]\n"
"  } //next\n"
"\n"
"  peek() { peek(1) }\n"
"  peek(n) {\n"
"    var idx = skips(false) + n\n"
"    if(idx >= _end) return _EOF\n"
"    return _points[idx]\n"
"  } //peek\n"
"\n"
"  peeks() { peeks(1) }\n"
"  peeks(n) {\n"
"    if(_cur+n >= _end) return _EOF\n"
"    return _points[_cur+n]\n"
"  } //peeks\n"
"\n"
"  step(consume) {\n"
"\n"
"    var cur = _cur + 1\n"
"    if(cur >= _end) {\n"
"      if(consume) _cur = _end\n"
"      return _EOF\n"
"    }\n"
"\n"
"    if(consume) {\n"
"      _cur = cur\n"
"      if(_points[cur] == _NEW_LINE) {\n"
"        _col = 0\n"
"        _line = _line + 1\n"
"      } else {\n"
"        _col = _col + 1\n"
"      }\n"
"    }\n"
"\n"
"    return _points[_cur]\n"
"\n"
"  } //step\n"
"\n"
"  skips(consume) {\n"
"\n"
"    var cur = _cur\n"
"    while(true) {\n"
"\n"
"      cur = cur + 1\n"
"      if(cur >= _end) {\n"
"        if(consume) _cur = _end\n"
"        return _end\n"
"      }\n"
"\n"
"      var tok = _points[cur]\n"
"\n"
"        //if not in comment state, increment state count\n"
"      if(_in_comment <= 1 && tok == _COMMENT) {\n"
"        //as long as the next token is actually a comment,\n"
"        //and the next token isn't outside the bounds of the string\n"
"        var nxt = (cur+1).min(_end-1)\n"
"        var nxt_tok = _points[nxt]\n"
"        if(nxt > cur && nxt_tok == _COMMENT) {\n"
"          _in_comment = _in_comment + 1\n"
"        }\n"
"      }\n"
"\n"
"        //end of line is a comment state reset, must be before break\n"
"      if(tok == _NEW_LINE) _in_comment = 0\n"
"\n"
"        //if not inside a comment, normal tokens apply\n"
"      if(_in_comment == 0 && !is_whitespace(tok)) {\n"
"        break\n"
"      }\n"
"\n"
"      if(consume) {\n"
"        _cur = cur\n"
"        if(tok == _NEW_LINE) {\n"
"          _col = 0\n"
"          _line = _line + 1\n"
"        } else {\n"
"          _col = _col + 1\n"
"        }\n"
"      }\n"
"\n"
"    } //while\n"
"\n"
"    return cur - 1\n"
"\n"
"  } //skips\n"
"\n"
"  parse_key() {\n"
"\n"
"    var key = ""\n"
"    var quoted = peek() == _OPEN_STRING\n"
"    if(quoted) next()\n"
"\n"
"    var first = next()\n"
"    if(!quoted && (first == _COLON || first == _EQUAL)) unexpected(first)\n"
"    if(is_token(first)) unexpected(first)\n"
"    if(is_eof(first)) unexpected(_EOF)\n"
"\n"
"    //:todo: escapes in keys are not handled\n"
"\n"
"    key = key + String.fromCodePoint(first)\n"
"    while(true) {\n"
"      var pk = peek()\n"
"      if(quoted) {\n"
"        if(pk == _CLOSE_STRING) break\n"
"      } else {\n"
"        if(pk == _COLON || pk == _EQUAL || pk == _CLOSE_STRING) break\n"
"      }\n"
"      var point = step(true)\n"
"      if(is_eof(point)) unexpected(_EOF)\n"
"      var upcoming = peek()\n"
"      var is_ending = (upcoming == _COLON || upcoming == _EQUAL)\n"
"      if(!is_ending) {\n"
"        key = key + String.fromCodePoint(point)\n"
"      } else if(!is_whitespace(point)) {\n"
"        key = key + String.fromCodePoint(point)\n"
"      }\n"
"    }\n"
"\n"
"    if(!quoted) {\n"
"      if(peeks() == _CLOSE_STRING) Fiber.abort("closing quote without open quote for key at line %(_line):%(_col) in file `%(_source_id)`")\n"
"    } else {\n"
"      var was = next() //disard the close quote\n"
"      if(was != _CLOSE_STRING) Fiber.abort("unclosed quotes for key at line %(_line):%(_col), a \" is missing here, in file `%(_source_id)` %(String.fromCodePoint(was))") //\"\n"
"    }\n"
"\n"
"    next() //discard colon/equal\n"
"    return key\n"
"\n"
"  } //parse_key\n"
"\n"
"  parse_primitive() {\n"
"\n"
"    var prim = ""\n"
"\n"
"    //consume whitespace\n"
"    skips(true)\n"
"\n"
"    while(true) {\n"
"\n"
"      var pk = peeks()\n"
"      if(is_token(pk)) break\n"
"      if(is_whitespace(pk)) break\n"
"\n"
"      var point = next()\n"
"\n"
"      if(is_eof(point)) unexpected(_EOF)\n"
"\n"
"      prim = prim + String.fromCodePoint(point)\n"
"\n"
"    } //while\n"
"\n"
"    return prim\n"
"\n"
"  } //parse_primitive\n"
"\n"
"  read_raw_string() {\n"
"\n"
"    var string = ""\n"
"    var eof = false\n"
"    var cur = _cur + 1\n"
"    while(true) {\n"
"      if(cur >= _end) {\n"
"        eof = true\n"
"        break\n"
"      }\n"
"      var point = _points[cur]\n"
"      var point1 = cur+1 < _end ? _points[cur+1] : -1\n"
"      var point2 = cur+2 < _end ? _points[cur+2] : -1\n"
"      if(point1 == -1 || point2 == -1) break //:todo: give an error when past the end\n"
"\n"
"      if(point == _CLOSE_STRING && point1 == _CLOSE_STRING && point2 == _CLOSE_STRING) {\n"
"        cur = cur + 2\n"
"        break\n"
"      }\n"
"\n"
"      var is_invalid = point == -1\n"
"      if(!is_invalid) {\n"
"        string = string + String.fromCodePoint(point)\n"
"      }\n"
"      cur = cur + 1\n"
"    }\n"
"\n"
"    _cur = cur //this consumes the close quote\n"
"\n"
"    return string\n"
"\n"
"  } //read_raw_string\n"
"\n"
"  read_string() {\n"
"\n"
"    var string = ""\n"
"    var eof = false\n"
"    var cur = _cur + 1\n"
"    var prev = _OPEN_STRING\n"
"    while(true) {\n"
"      if(cur >= _end) {\n"
"        eof = true\n"
"        break\n"
"      }\n"
"      var point = _points[cur]\n"
"      var is_invalid = point == -1\n"
"      if(point == _CLOSE_STRING && prev != _ESCAPED) break\n"
"      var escaped = point == _ESCAPED && _points[cur+1] == _CLOSE_STRING\n"
"      if(!escaped && !is_invalid) {\n"
"        string = string + String.fromCodePoint(point)\n"
"      }\n"
"      if(!is_invalid) prev = point\n"
"      cur = cur + 1\n"
"    }\n"
"\n"
"    _cur = cur //this consumes the close quote\n"
"\n"
"    return string\n"
"  } //read_string\n"
"\n"
"  parse_string() {\n"
"    \n"
"    next() //consume open quote\n"
"\n"
"    if(peeks() == _OPEN_STRING && peeks(2) == _OPEN_STRING) {\n"
"      next()\n"
"      next()\n"
"      return read_raw_string()\n"
"    }\n"
"\n"
"    return read_string()\n"
"\n"
"  } //parse_string\n"
"\n"
"  parse_value() {\n"
"\n"
"    var pk = peek()\n"
"\n"
"    if(pk == _OPEN_BRACE)   return parse_map()\n"
"    if(pk == _OPEN_BRACKET) return parse_list()\n"
"    if(pk == _OPEN_STRING)  return parse_string()\n"
"\n"
"    var prim = parse_primitive()\n"
"\n"
"    if(prim == "false") return false\n"
"    if(prim == "true") return true\n"
"    if(prim == "null") return null\n"
"\n"
"    return Num.fromString(prim)\n"
"\n"
"  } //parse_value\n"
"\n"
"  parse_list() {\n"
"\n"
"    next() //consume the open bracket\n"
"\n"
"    var list = []\n"
"\n"
"    while(true) {\n"
"\n"
"      if(peek() == _CLOSE_BRACKET) break\n"
"\n"
"      list.add(parse_value())\n"
"\n"
"      var pk = peek()\n"
"      if(pk == _CLOSE_BRACKET) break\n"
"      if(pk == _COMMA) next() //consume comma, keep going\n"
"\n"
"    } //while\n"
"\n"
"    next() //consume close bracket\n"
"\n"
"    return list\n"
"\n"
"  } //parse_list\n"
"\n"
"  parse_map() {\n"
"\n"
"    next() //consume the open brace\n"
"\n"
"    var map = parse_map_value()\n"
"\n"
"    next() //consume close brace\n"
"\n"
"    return map\n"
"\n"
"  } //parse_map\n"
"\n"
"  parse_map_value() {\n"
"\n"
"    var map = {}\n"
"\n"
"    while(true) {\n"
"      if(peek() == _EOF) break\n"
"      if(peek() == _CLOSE_BRACE) break\n"
"\n"
"      var key = parse_key()\n"
"      var value = parse_value()\n"
"      map[key] = value\n"
"\n"
"      var pk = peek()\n"
"      if(peek() == _CLOSE_BRACE) break\n"
"      if(pk == _COMMA) next() //consume comma, keep going\n"
"    }\n"
"\n"
"    return map\n"
"\n"
"  } //parse_map\n"
"\n"
"} //JsonParser\n";
